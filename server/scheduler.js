/**
 * ProgramScheduler - Executes multi-step light programs over time
 *
 * Receives a program JSON (generated by the LLM), then:
 * - Runs steps sequentially with proper timing
 * - Handles loops (repeat step ranges N times)
 * - Tracks state for status queries
 * - Supports pause/resume/cancel
 *
 * Each step's `command` is passed directly to the server's handleCommand(),
 * which already knows how to talk to the LED controller and pattern engine.
 */

import { GridRenderer } from './renderer.js';

export class ProgramScheduler {
    constructor(handleCommandFn, broadcastFn) {
        this.handleCommand = handleCommandFn;
        this.broadcast = broadcastFn;
        this.renderer = new GridRenderer();

        this.program = null;
        this.state = 'idle'; // idle | running | paused
        this.currentStepIndex = 0;
        this.loopIteration = 0;
        this.stepTimer = null;
        this.stepStartTime = null;
        this.pausedRemaining = null;
    }

    /**
     * Load and start a program
     */
    start(program) {
        this.cancel();

        const error = this.validate(program);
        if (error) {
            return { success: false, error };
        }

        this.program = program;
        this.state = 'running';
        this.currentStepIndex = 0;
        this.loopIteration = 0;

        this.broadcastStatus('program_started');
        this.executeCurrentStep();

        return { success: true, name: program.name, steps: program.steps.length };
    }

    /**
     * Validate a program before running
     */
    validate(program) {
        if (!program || !program.steps || !Array.isArray(program.steps)) {
            return 'Program must have a "steps" array';
        }
        if (program.steps.length === 0) {
            return 'Program must have at least one step';
        }
        for (let i = 0; i < program.steps.length; i++) {
            const step = program.steps[i];
            if (!step.id) {
                return `Step ${i} is missing "id"`;
            }
            if (!step.command) {
                return `Step "${step.id}" is missing "command"`;
            }
            if (!step.command.type) {
                return `Step "${step.id}" command is missing "type"`;
            }
        }
        if (program.loop) {
            const { start_step, end_step, count } = program.loop;
            if (start_step && !program.steps.find(s => s.id === start_step)) {
                return `Loop start_step "${start_step}" not found`;
            }
            if (end_step && !program.steps.find(s => s.id === end_step)) {
                return `Loop end_step "${end_step}" not found`;
            }
        }
        return null;
    }

    /**
     * Execute the current step
     */
    executeCurrentStep() {
        if (this.state !== 'running' || !this.program) return;

        const step = this.program.steps[this.currentStepIndex];
        if (!step) {
            this.onProgramComplete();
            return;
        }

        // If command is a render type, convert to bulk LED data first
        const command = step.command.type === 'render'
            ? this.renderer.render(step.command.elements || [])
            : step.command;
        this.handleCommand(command);
        this.stepStartTime = Date.now();

        this.broadcastStatus('step_started');

        // If duration is null/undefined/non-numeric, this step runs indefinitely
        const duration = typeof step.duration === 'number' ? step.duration : null;
        if (duration == null) {
            return;
        }

        // Schedule the next step
        this.stepTimer = setTimeout(() => {
            this.advanceToNextStep();
        }, duration);
    }

    /**
     * Advance to the next step, handling loops
     */
    advanceToNextStep() {
        if (this.state !== 'running') return;

        const currentStep = this.program.steps[this.currentStepIndex];
        const loop = this.program.loop;

        // Check if we're at the end of a loop range
        if (loop && this.isLoopEndStep(currentStep.id)) {
            const maxCount = loop.count || 0; // 0 = infinite
            this.loopIteration++;

            if (maxCount === 0 || this.loopIteration < maxCount) {
                // Loop back to start
                const startIndex = this.getLoopStartIndex();
                this.currentStepIndex = startIndex;
                this.broadcastStatus('loop_iteration');
                this.executeCurrentStep();
                return;
            }
            // Loop complete, fall through to next step
        }

        this.currentStepIndex++;

        if (this.currentStepIndex >= this.program.steps.length) {
            this.onProgramComplete();
        } else {
            this.executeCurrentStep();
        }
    }

    /**
     * Check if a step ID is the loop end step
     */
    isLoopEndStep(stepId) {
        const loop = this.program.loop;
        if (!loop) return false;

        if (loop.end_step) {
            return stepId === loop.end_step;
        }
        // Default: last step is loop end
        return this.currentStepIndex === this.program.steps.length - 1;
    }

    /**
     * Get the index of the loop start step
     */
    getLoopStartIndex() {
        const loop = this.program.loop;
        if (!loop || !loop.start_step) return 0;

        const index = this.program.steps.findIndex(s => s.id === loop.start_step);
        return index >= 0 ? index : 0;
    }

    /**
     * Called when the program finishes all steps
     */
    onProgramComplete() {
        this.state = 'idle';
        clearTimeout(this.stepTimer);
        this.stepTimer = null;

        // Run on_complete command if specified
        if (this.program.on_complete && this.program.on_complete.command) {
            this.handleCommand(this.program.on_complete.command);
        }

        this.broadcastStatus('program_complete');
        this.program = null;
    }

    /**
     * Pause the current program
     */
    pause() {
        if (this.state !== 'running') {
            return { success: false, error: 'Not running' };
        }

        this.state = 'paused';

        // Calculate remaining time for current step
        if (this.stepTimer && this.stepStartTime) {
            const step = this.program.steps[this.currentStepIndex];
            if (typeof step.duration === 'number') {
                const elapsed = Date.now() - this.stepStartTime;
                this.pausedRemaining = Math.max(0, step.duration - elapsed);
            }
        }
        clearTimeout(this.stepTimer);
        this.stepTimer = null;

        this.broadcastStatus('program_paused');
        return { success: true };
    }

    /**
     * Resume a paused program
     */
    resume() {
        if (this.state !== 'paused') {
            return { success: false, error: 'Not paused' };
        }

        this.state = 'running';

        // Re-execute current step's command (pattern may have been overridden)
        const step = this.program.steps[this.currentStepIndex];
        const command = step.command.type === 'render'
            ? this.renderer.render(step.command.elements || [])
            : step.command;
        this.handleCommand(command);
        this.stepStartTime = Date.now();

        if (this.pausedRemaining != null && this.pausedRemaining > 0) {
            this.stepTimer = setTimeout(() => {
                this.advanceToNextStep();
            }, this.pausedRemaining);
        } else if (step.duration != null) {
            // Step with duration but no remaining â€” advance immediately
            this.advanceToNextStep();
        }
        // If duration is null, step stays indefinitely (same as before pause)

        this.pausedRemaining = null;
        this.broadcastStatus('program_resumed');
        return { success: true };
    }

    /**
     * Cancel the current program
     */
    cancel() {
        if (this.state === 'idle') return { success: true };

        clearTimeout(this.stepTimer);
        this.stepTimer = null;

        // Run on_cancel command if specified
        if (this.program && this.program.on_cancel && this.program.on_cancel.command) {
            this.handleCommand(this.program.on_cancel.command);
        }

        this.state = 'idle';
        this.program = null;
        this.currentStepIndex = 0;
        this.loopIteration = 0;
        this.pausedRemaining = null;

        this.broadcastStatus('program_cancelled');
        return { success: true };
    }

    /**
     * Get current status
     */
    getStatus() {
        if (this.state === 'idle' || !this.program) {
            return { state: 'idle' };
        }

        const step = this.program.steps[this.currentStepIndex];
        const loop = this.program.loop;

        let elapsed = 0;
        let remaining = null;

        if (this.state === 'paused' && this.pausedRemaining != null) {
            remaining = this.pausedRemaining;
            elapsed = step.duration != null ? step.duration - this.pausedRemaining : 0;
        } else if (this.stepStartTime && step.duration != null) {
            elapsed = Date.now() - this.stepStartTime;
            remaining = Math.max(0, step.duration - elapsed);
        }

        return {
            state: this.state,
            program_name: this.program.name,
            current_step: {
                index: this.currentStepIndex,
                id: step.id,
                elapsed_ms: elapsed,
                remaining_ms: remaining,
                duration_ms: step.duration
            },
            total_steps: this.program.steps.length,
            loop: loop ? {
                iteration: this.loopIteration,
                total: loop.count || 'infinite'
            } : null
        };
    }

    /**
     * Broadcast a status update to WebSocket clients
     */
    broadcastStatus(event) {
        this.broadcast({
            type: 'program_status',
            event,
            ...this.getStatus()
        });
    }
}

export default ProgramScheduler;
